---
import ProjectCard from "./ProjectCard.astro";

// Define the data structure for your projectCards
interface ProjectCards {
  title: string;
  description: string;
  href: string;
  modelUrl: string;
  previewImg: ImageMetadata;
}

import { getLangFromUrl, useTranslations } from "../i18n/utils";
const t = useTranslations(getLangFromUrl(Astro.url));

// import { Image } from 'astro:assets';

import tdaImg from "../assets/TDA75610.png";

import ultrasonicImg from "../assets/UltraSonic.png";

import termocoupleImg from "../assets/termocouple.png";

// You can pass these as props, or define them right here
const projectCards: ProjectCards[] = [
  {
    title: t("kicad.card1").title,
    description: t("kicad.card1").desc,
    href: "/Blog/Kicad/TDA75610.html",
    modelUrl: "/models/TDA75610.glb",
    previewImg: tdaImg,
  },
  {
    title: t("kicad.card2").title,
    description: t("kicad.card2").desc,
    href: "/Blog/Kicad/ultrasonic.html",
    modelUrl: "/models/UltraSonic.glb",
    previewImg: ultrasonicImg,
  },
  {
    title: t("kicad.card3").title,
    description: t("kicad.card3").desc,
    href: "#",
    modelUrl: "/models/ESP01-Driver.glb",
    previewImg: termocoupleImg,
  },
];
---

<section id="kicad">
  {
    projectCards.map((Card) => (
      <ProjectCard
        title={Card.title}
        description={Card.description}
        href={Card.href}
        modelUrl={Card.modelUrl}
        previewImg={Card.previewImg}
      />
    ))
  }
  <!-- <ProjectCard title={`"${projectCards[0].title}"`} description={`"${projectCards[0].description}"`} href={`"${projectCards[0].href}"`} modelUrl={`"${projectCards[0].modelUrl}"`} previewImg={`"${projectCards[0].previewImg}"`} />  -->
</section>

<style>
  section#kicad {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10vh;
    padding: 10vh 0;
    background-color: var(--bg-color);
    background-image:
      linear-gradient(#ffffff0a 1px, transparent 1px),
      linear-gradient(90deg, #ffffff0a 1px, transparent 1px);
    background-size: 50px 50px;
    overflow: hidden;
  }
</style>

<script>
  import * as THREE from "three";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

  class Viewer3D {
    constructor(containerEl) {
      this.container = containerEl;
      this.url = containerEl.dataset.modelUrl || "";
      this._abortController = null;

      // Select elements generated by Astro instead of creating them
      this.previewWrapper = this.container.querySelector(
        ".viewer-preview-wrapper",
      );
      this.preview = this.container.querySelector(".viewer-preview");
      this.startBanner = this.container.querySelector(".startBanner");
      this.loadProgress = this.container.querySelector(".loadProgress");
      this.loadProgressP = this.loadProgress.querySelector("p");

      // Bind events
      this.bindEvents();
    }

    bindEvents() {
      if (this.startBanner) {
        this.startBanner.addEventListener("click", () => this.startViewer());
        this.startBanner.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            this.startViewer();
          }
        });
      }

      if (this.preview) {
        this.preview.addEventListener("click", () => this.startViewer());
      }
    }

    startViewer() {
      if (!this.url) {
        this.loadProgressP.innerText = "No 3D model";
        this.loadProgress.style.display = "flex";
        setTimeout(() => {
          this.loadProgress.style.display = "none";
        }, 1200);
        return;
      }

      // Hide preview, show loader
      this.previewWrapper.style.display = "none";
      this.loadProgress.style.display = "flex";

      // Create Canvas Container (Dynamic to save resources)
      this.canvasWrap = document.createElement("div");
      this.canvasWrap.className = "viewer-canvas";
      this.container.appendChild(this.canvasWrap);

      // Create Controls (Unload / Fullscreen)
      this.createControls();

      this.initThree();
      this.loadModel();
    }

    createControls() {
      this.unloadBtn = document.createElement("button");
      this.unloadBtn.className = "viewer-unload-btn";
      this.unloadBtn.title = "Cerrar Modelo";
      this.unloadBtn.innerText = "×";
      this.unloadBtn.addEventListener("click", () => this.resetViewer());
      this.canvasWrap.appendChild(this.unloadBtn);

      this.fullscreenBtn = document.createElement("button");
      this.fullscreenBtn.className = "viewer-fullscreen-btn";
      this.fullscreenBtn.title = "Pantalla Completa";
      this.fullscreenBtn.innerText = "⛶";
      this.fullscreenBtn.addEventListener("click", () =>
        this.toggleFullscreen(),
      );
      this.canvasWrap.appendChild(this.fullscreenBtn);
    }

    toggleFullscreen() {
      if (!document.fullscreenElement) {
        if (this.container.requestFullscreen)
          this.container.requestFullscreen();
        else if (this.container.webkitRequestFullscreen)
          this.container.webkitRequestFullscreen();
        else if (this.container.mozRequestFullScreen)
          this.container.mozRequestFullScreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
      }
    }

    resetViewer() {
      if (document.fullscreenElement === this.container) {
        if (document.exitFullscreen) document.exitFullscreen();
      }
      if (this._abortController) {
        this._abortController.abort();
        this._abortController = null;
      }

      // Cleanup DOM
      window.removeEventListener("resize", this.resizeBind, false);
      // Remove listeners if they exist
      if (this.fullscreenChangeBind) {
        document.removeEventListener(
          "fullscreenchange",
          this.fullscreenChangeBind,
          false,
        );
        document.removeEventListener(
          "webkitfullscreenchange",
          this.fullscreenChangeBind,
          false,
        );
        document.removeEventListener(
          "mozfullscreenchange",
          this.fullscreenChangeBind,
          false,
        );
      }

      // Dispose Three.js
      if (this.renderer) {
        this.renderer.dispose && this.renderer.dispose();
        this.renderer.forceContextLoss && this.renderer.forceContextLoss();
      }

      // Remove canvas wrapper
      if (this.canvasWrap && this.canvasWrap.parentNode) {
        this.canvasWrap.parentNode.removeChild(this.canvasWrap);
      }

      this.scene =
        this.camera =
        this.renderer =
        this.controls =
        this.content =
          null;

      // Reset UI state
      this.previewWrapper.style.display = "";
      this.loadProgress.style.display = "none";
      this.loadProgressP.innerText = "Cargando..."; // Reset text
    }

    initThree() {
      // Get colors from CSS variables or fallback
      const bgStyle =
        getComputedStyle(document.documentElement)
          .getPropertyValue("--bg-color")
          .trim() || "#0a0b10";
      this.backgroundColor = new THREE.Color(bgStyle);

      this.scene = new THREE.Scene();
      this.scene.background = this.backgroundColor;

      const width = this.container.clientWidth;
      const height = this.container.clientHeight;

      this.camera = new THREE.PerspectiveCamera(15, width / height, 0.1, 2000);
      this.camera.position.set(0, 0, 10);
      this.scene.add(this.camera);

      this.renderer = new THREE.WebGLRenderer({ antialias: true });
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(width, height);
      this.canvasWrap.appendChild(this.renderer.domElement);

      const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
      this.scene.environment = pmremGenerator.fromScene(
        new RoomEnvironment(),
      ).texture;

      this.controls = new OrbitControls(this.camera, this.renderer.domElement);
      this.controls.screenSpacePanning = true;

      this.resizeBind = this.resize.bind(this);
      this.fullscreenChangeBind = this.fullscreenChange.bind(this);

      window.addEventListener("resize", this.resizeBind, false);
      document.addEventListener(
        "fullscreenchange",
        this.fullscreenChangeBind,
        false,
      );
      document.addEventListener(
        "webkitfullscreenchange",
        this.fullscreenChangeBind,
        false,
      );
      document.addEventListener(
        "mozfullscreenchange",
        this.fullscreenChangeBind,
        false,
      );

      this.animate = this.animate.bind(this);
      requestAnimationFrame(this.animate);
    }

    fullscreenChange() {
      requestAnimationFrame(() => this.resize());
    }

    animate() {
      // Stop animation loop if renderer is gone (resetViewer called)
      if (!this.renderer) return;

      requestAnimationFrame(this.animate);
      if (this.controls) this.controls.update();
      if (this.renderer && this.scene && this.camera)
        this.renderer.render(this.scene, this.camera);
    }

    resize() {
      if (!this.canvasWrap || !this.camera || !this.renderer) return;
      const fsEl =
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        null;
      const target = fsEl === this.container ? fsEl : this.container;
      const width = target.clientWidth;
      const height = target.clientHeight;
      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(width, height);
    }

    loadModel() {
      let controller = null;
      if (window.AbortController) {
        controller = new AbortController();
        this._abortController = controller;
      }

      const loader = new GLTFLoader();
      if (controller) {
        try {
          loader.manager.setURLModifier((url) => {
            return new Request(url, { signal: controller.signal });
          });
        } catch (e) {
          /* ignore */
        }
      }

      loader.load(
        this.url,
        (gltf) => {
          this._abortController = null;
          const scene = gltf.scene || (gltf.scenes && gltf.scenes[0]);
          if (!scene) {
            this.loadProgressP.innerText = "Escena vacía";
            setTimeout(() => this.resetViewer(), 1500);
            return;
          }
          // Slight background change when loaded if desired, or keep default
          this.backgroundColor.setHex(0x232425);
          this.scene.background = this.backgroundColor;

          this.loadProgress.style.display = "none";
          this.setContent(scene);
        },
        (xhr) => {
          if (xhr && xhr.total)
            this.loadProgressP.innerHTML = `${((xhr.loaded * 100) / xhr.total).toFixed(1)}%`;
        },
        (err) => {
          if (controller && controller.signal.aborted) {
            this.loadProgressP.innerHTML = "Carga abortada";
          } else {
            console.error("Error cargando", err);
            this.loadProgressP.innerHTML = "Error";
          }
          setTimeout(() => this.resetViewer(), 2000);
          this._abortController = null;
        },
      );
    }

    setContent(object) {
      this.clear();
      object.updateMatrixWorld();
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3()).length();
      const center = box.getCenter(new THREE.Vector3());

      object.position.x -= center.x;
      object.position.y -= center.y;
      object.position.z -= center.z;

      this.controls.reset();
      this.controls.maxDistance = size * 5;
      this.camera.near = Math.max(size / 100, 0.01);
      this.camera.far = size * 100;
      this.camera.updateProjectionMatrix();
      this.camera.position.copy(center);
      this.camera.position.x += size;
      this.camera.position.y += size;
      this.camera.position.z += size;
      this.camera.lookAt(center);
      this.scene.add(object);
      this.content = object;
    }

    clear() {
      if (!this.content) return;
      this.scene.remove(this.content);
      this.content.traverse((node) => {
        if (!node.geometry) return;
        node.geometry.dispose();
      });
    }
  }

  // Initialisation Logic
  const initAll = () => {
    const els = document.querySelectorAll(".viewer3d");
    els.forEach((el) => {
      // Avoid re-init if Astro view transitions are not used
      if (!el.__viewer3d) el.__viewer3d = new Viewer3D(el);
    });
  };

  initAll();

  // If using Astro View Transitions, uncomment the following:
  // document.addEventListener('astro:page-load', initAll);
</script>
